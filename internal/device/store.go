package device

import (
	"os"
	"path/filepath"
	"sync"

	log "github.com/sirupsen/logrus"
	"gopkg.in/yaml.v3"
)

const (
	bindingsFileName = "device-bindings.yaml"
	fileHeader       = "# Auto-generated by CLIProxyAPI - DO NOT EDIT MANUALLY\n# Device bindings: maps API key -> device identifier\n\n"
)

// Store manages persistence of device bindings
type Store struct {
	mu       sync.RWMutex
	filePath string
	bindings *DeviceBindings
}

// NewStore creates a new Store instance
func NewStore(authDir string) (*Store, error) {
	filePath := filepath.Join(authDir, bindingsFileName)
	store := &Store{
		filePath: filePath,
		bindings: NewDeviceBindings(),
	}

	// Load existing bindings if file exists
	if err := store.load(); err != nil {
		log.Warnf("device-binding: failed to load bindings from %s: %v", filePath, err)
		// Continue with empty bindings
	}

	return store, nil
}

// load reads bindings from YAML file
func (s *Store) load() error {
	s.mu.Lock()
	defer s.mu.Unlock()

	data, err := os.ReadFile(s.filePath)
	if err != nil {
		if os.IsNotExist(err) {
			// File doesn't exist yet, start with empty bindings
			return nil
		}
		return err
	}

	var bindings DeviceBindings
	if err := yaml.Unmarshal(data, &bindings); err != nil {
		log.Warnf("device-binding: invalid YAML in %s, starting with empty bindings", s.filePath)
		return nil
	}

	if bindings.Bindings == nil {
		bindings.Bindings = make(map[string]DeviceBinding)
	}
	s.bindings = &bindings
	return nil
}

// save writes bindings to YAML file
func (s *Store) save() error {
	// Ensure directory exists
	dir := filepath.Dir(s.filePath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}

	data, err := yaml.Marshal(s.bindings)
	if err != nil {
		return err
	}

	content := fileHeader + string(data)
	return os.WriteFile(s.filePath, []byte(content), 0644)
}

// Get returns the binding for an API key
func (s *Store) Get(apiKey string) (DeviceBinding, bool) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.bindings.Get(apiKey)
}

// Save creates a new binding for an API key and persists to disk
func (s *Store) Save(apiKey, deviceID, deviceType string) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	s.bindings.Set(apiKey, deviceID, deviceType)
	return s.save()
}

// UpdateLastSeen updates the last_seen timestamp and persists
func (s *Store) UpdateLastSeen(apiKey string) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	s.bindings.UpdateLastSeen(apiKey)
	return s.save()
}

// Delete removes a binding and persists
func (s *Store) Delete(apiKey string) (bool, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	deleted := s.bindings.Delete(apiKey)
	if deleted {
		if err := s.save(); err != nil {
			return false, err
		}
	}
	return deleted, nil
}

// Clear removes all bindings and persists
func (s *Store) Clear() error {
	s.mu.Lock()
	defer s.mu.Unlock()

	s.bindings.Clear()
	return s.save()
}

// GetAll returns a copy of all bindings
func (s *Store) GetAll() map[string]DeviceBinding {
	s.mu.RLock()
	defer s.mu.RUnlock()

	result := make(map[string]DeviceBinding, len(s.bindings.Bindings))
	for k, v := range s.bindings.Bindings {
		result[k] = v
	}
	return result
}

// MaskKey masks an API key for logging (shows first 4 and last 4 chars)
func MaskKey(key string) string {
	if len(key) <= 8 {
		return "****"
	}
	return key[:4] + "****" + key[len(key)-4:]
}
